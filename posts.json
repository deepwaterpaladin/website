[
    {
        "id": "graphs",
        "title": "A Practical Implementation of Graphs",
        "author": "Rielly H. Young",
        "date": "July 6th, 2024",
        "content": 
        [
            "A common difficulty faced by organizations is the inability to quantify the relationship between abstract business objects. A makeshift solution is often the establishment of key performance indicators, when aggregated, seek to provide quantifiable feedback related to a specific indicator. These KPIs can be used a proxy to compare various abstract objects against one another. But what if you were trying to compare a large number of products to one another, based off qualities that were unable to be easily quantified? What if your company provides a wide number of services across departments, and you wanted to determine which of these had the most overlap?",
            "This is a problem that is faced by many organizations - both public and private. This was the problem facing my team when trying to quantify the similarity of programs across the organization. We had an array of over 400 business objects with 30+ properties of various datatypes that needed to be compared to one another. The outcome of this comparison was to identify the programs with the highest similarity - as to allow for more efficiently direction of organizational resources. The following case will implement the same logic to a different set of abstract objects to demonstrate the usefulness of graphs.",
            "Consider a problem where we need to compare companies listed in the S&P500; trying to find the companies that are the most 'alike'. There are many ways one could define 'alike': the products they sell or the services they engage in, the number of employees they have or their market capitalization. All these methods would arguably work fine, but most likely fail to yield any interesting patterns; I would argue, because they are too narrow in scope. Therein lies the problem: how can we quantify a relationship between two or more objects based on the widest variety of their shared properties? This is where the concept of a graph comes into play.",
            "This by no means is an exhaustive explanation of graphs; rather a primer for the purposes of understand this example. At the most basic level, a graph is an abstract data structure that is made up of a set of nodes (also called vertices) and a set of unordered edges, which represent a connection between two nodes. These can be directed or undirected, but for our purposes we care about directed. These will sometimes be referred to as digraphs. Edges can also have values, which will be important to our implementation of them. Another import aspect of graphs is their means for traversal. While graph traversal can be accomplished with breadth-first search (BFS) or depth-first search (DFS), our implementation utilized the latter. This importance of this will be highlighted in further detail.",
            "So, we understand now that we’re going to build a graph where the nodes represent stocks in the S&P500 - we’re half of the way there. What is missing? The edges. These represent the distance (or similarity in our case) between two nodes. To calculate this distance between two nodes, we implement a summation of each property’s Levenshtein distance. The Levenshtein distance between two string is the representation of the number of single character edits required to turn one string into another. Our implementation assumed two strings would have a distance between zero (completely different) to one hundred (identical strings). This is an inverse of a typical implementation, but it will make sense as we move on.",
            "Now we have everything we need to make the comparisons: we know what data structure we’re going to use, and we know how we’re going to quantify the edge distances. The rest is quite simple. Below is the C# implementation of a graph, with a few (not all) methods. Full definitions for Obj and NodePair can be found at the end of this document in Appendix A.",
            "* \npublic class Graph \n{\n   private HashSet<Obj> nodes { get; } = new();\n   private HashSet<NodePair> edges { get; } = new();\n}\n\n",
            "While a typical implementation of the graph data structure has more methods that are shown here, only AddNode and AddEdge are important to us. We start out with a graph with no nodes; we iterate through our list of stocks, adding them to the graph one by one. If nodes are empty, we add a new node; if not, we add an edge to edges between the new node and every other node within nodes. Because our graph’s nodes are bidirectional, we create the minimum number of edges required.",
            "* \npublic void Graph.AddNode(Obj node)\n{\n    if (nodes.Count == 0)\n    {\n        nodes.Add(node);\n    }\n    else\n    {\n        foreach (Obj oldNode in nodes)\n        {\n            AddEdge(node, oldNode);\n        }\n        nodes.Add(node);\n    }\n}\n\nprivate void Graph.AddEdge(Obj node1, Obj node2)\n{\n    NodePair np = new(node1, node2);\n    edges.Add(np);\n}\n\n",
            "Distance of the edge is calculated at the edge level (again, which can be seen in Appendix A). Using object reflection, we compare every property of the object (stock in our case). Once the nodes have been added to the graph, determining which nodes are most alike is as simple as providing the GetEdges(double threshold) method a threshold.",
            "* \npublic List<NodePair> Graph.GetEdges(double threshold)\n{\n     return edges.Where(edge => threshold <= edge.distance).ToList().OrderByDecending(e => e.distance).ToList();\n}\n\n",
            "For example, if the threshold was set to 85, only edges with values greater than 85 would be returned - in other words, only stock pairs that were more than 85% identical would be shown. Thus, we now have a list containing the most similar stocks in descending order that we can use for further analysis. ",
            "There are five hundred stocks in the S&P500. If we wanted an algorithm to compare each stock to every other one, it’s algorithmic complexity would be O(n!) where n! represents a factorial of the number of stocks (500!). On the other hand, implementing a BFS of our stock graph would have a time complexity of O(|N| + |E|), where N represents the number of nodes (stocks) and E represents the number of edge pairs. From an efficiency perspective, the implementation of a graph based DFS is by far the superior method. ",
            "Wrapping up, the implementation of a graph with edge distances calculated by Levenshtein distance is an easy & efficient means for quantifying the relationship between abstract objects. My initial implementation for determining the similarities between programs across our organization. We were able to make connections between programs that hadn’t been previous identified due to the vast quantity of data.",
            "Appendix A.",
            "* \nusing FuzzySharp; \n\npublic class Obj\n{\n    public string prop1 { get; set; }\n    public int prop2 { get; set;}\n    public DateTime prop3 { get; set;}\n    \n    // remaining properties\n}\n\npublic class NodePair(Obj node1, Obj node2)\n{\n    public Obj node1 { get; set; }\n    public Obj node2 { get; set; }\n    public int distance { get; }\n\n    public NodePair( Obj one, Obj two)\n    {\n        node1 = one;\n        node2 = two;\n        distance = SetEdgeDistance(one, two);\n    }\n\n    private static double SetEdgeDistance(Obj node1, Obj node2)\n    {\n        PropertyInfo[] properties = typeof(Obj).GetProperties();\n        int numberOfProperties = properties.Length;\n        double distance = 0;\n        for (int i = 0; i < numberOfProperties; i++)\n        {\n            object val1 = properties[i].GetValue(node1);\n            object val2 = properties[i].GetValue(node2);\n            if (val1 == null || val2 == null)\n            {\n                distance = 1; // when both props are null it is treated as identical.\n            }\n            else\n            {\n                distance = Levenshtein.GetRatio(val.ToString(), val.ToString());\n            }\n        }\n        return distance/numberOfProperties;\n    }\n}"
        ]
    },
    {
        "id": "test-post",
        "title": "Test Post",
        "author": "Rielly H. Young",
        "date": "June 8th, 2024",
        "content": 
        [
            "I'm adding a blog to my personal website. Partially to statisfy an urge to write more; partially to try out new things with Flask. If you're reading this, it means you're a bit early. I'll soon be updating this page with my actual thoughts. The remainder of this post will contain standard dummy text.",
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer eget pulvinar magna, vitae sollicitudin diam. Cras ullamcorper dui fermentum, hendrerit leo non, imperdiet magna. Pellentesque eu diam vitae urna euismod auctor. In maximus semper magna id gravida. Fusce sit amet imperdiet felis. Phasellus ut laoreet odio. Integer ac lobortis ipsum, ac sodales eros. Nulla quis neque leo. Phasellus nec porttitor dui, id auctor ligula. Mauris felis ligula, suscipit id nibh quis, congue iaculis est. Fusce pellentesque nec urna et gravida. Vestibulum feugiat felis eu erat lacinia accumsan.", 
            "Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Nullam id blandit lacus. Nulla quam justo, pulvinar sed eros et, consequat finibus purus. Morbi non augue in ligula vestibulum scelerisque aliquet vitae libero. Nullam mauris tellus, posuere vitae leo vel, bibendum consequat magna. Morbi facilisis justo non lacus fringilla, ut elementum nulla placerat. Mauris tempor neque eget pharetra congue. Quisque condimentum mauris id maximus pretium. Quisque interdum placerat venenatis. Phasellus ante ipsum, pharetra non sagittis sit amet, vulputate et libero. Quisque ut nulla ex. Pellentesque vel ultricies magna. Curabitur gravida dignissim euismod. Vestibulum viverra tempor urna, at fermentum leo bibendum id. Aliquam ac lacus sit amet lorem mattis viverra vel nec sem.",
            "Vestibulum et lorem dapibus, rhoncus ex a, ornare nisi. Aliquam fermentum rhoncus mattis. Nam vehicula tortor sem, id hendrerit neque semper eu. Maecenas scelerisque tempor ante pharetra pulvinar. Praesent placerat ex sapien, a lobortis sem lacinia sit amet. Sed quis sapien quis nisl tempus vehicula. Curabitur porta id elit vel congue. Cras gravida odio non dolor egestas varius.",
            "Suspendisse scelerisque tortor at ante blandit, id interdum risus eleifend. Phasellus eget ullamcorper arcu. In hac habitasse platea dictumst. Morbi ultrices non purus eget semper. Praesent leo nulla, interdum sit amet dolor sollicitudin, ultrices suscipit est. Donec ut sagittis arcu. Nullam tristique felis magna, vel vulputate nibh dapibus id. Phasellus consectetur tellus at lectus dignissim tempor. Curabitur consectetur gravida metus in dictum. Ut ullamcorper, nulla in fringilla porttitor, mi nulla venenatis justo, eget tristique justo est ac mauris. Nullam sollicitudin magna ante, a molestie tortor eleifend at. Cras tempus eu purus sed consequat. Curabitur viverra vitae enim at bibendum. Duis mollis metus nisi, non condimentum purus ultrices non. Curabitur nisi ex, aliquam in enim consectetur, rhoncus feugiat ligula. Maecenas at dui at felis commodo vehicula eu a velit",
            "Fusce finibus dictum leo, at efficitur enim ultricies ac. Praesent mattis mi vitae urna mattis tincidunt. Integer quis convallis lectus. Nam bibendum eget felis nec posuere. Duis blandit turpis eget suscipit vehicula. Duis non lectus ut libero vestibulum iaculis. Proin cursus nisi orci. Mauris sit amet semper nisi, sit amet tempor dolor. Vivamus non accumsan lectus, id varius leo."
        ]
    }
]